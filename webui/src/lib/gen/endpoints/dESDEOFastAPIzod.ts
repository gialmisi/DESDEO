/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * DESDEO (fast)API
 * A rest API for the DESDEO framework.
 * OpenAPI spec version: 0.1.0
 */
import zod from 'zod';

/**
 * Return information about the current user.

Args:
    user (Annotated[User, Depends): user dependency, handled by `get_current_user`.

Returns:
    UserPublic: public information about the current user.
 * @summary Get Current User Info
 */
export const getCurrentUserInfoUserInfoGetResponse = zod
	.object({
		username: zod.string(),
		id: zod.number(),
		role: zod.enum(['guest', 'dm', 'analyst', 'admin']).describe('Possible user roles.'),
		group_ids: zod.union([zod.array(zod.number()), zod.null()])
	})
	.describe('The object to handle public user information.');

/**
 * Login to get an authentication token.

Return an access token in the response and a cookie storing a refresh token.

Args:
    form_data (Annotated[OAuth2PasswordRequestForm, Depends()]):
        The form data to authenticate the user.
    session (Annotated[Session, Depends(get_db)]): The database session.
    cookie_max_age (int): the lifetime of the cookie storing the refresh token.
 * @summary Login
 */
export const loginLoginPostQueryCookieMaxAgeDefault = 30;

export const loginLoginPostQueryParams = zod.object({
	cookie_max_age: zod.number().default(loginLoginPostQueryCookieMaxAgeDefault)
});

export const loginLoginPostResponse = zod
	.object({
		access_token: zod.string(),
		refresh_token: zod.string(),
		token_type: zod.string()
	})
	.describe('A model for the authentication token.');

/**
 * Log the current user out. Deletes the refresh token that was set by logging in.

Args:
    None

Returns:
    JSONResponse: A response in which the cookies are deleted
 * @summary Logout
 */
export const logoutLogoutPostResponse = zod.any();

/**
 * Refresh the access token using the refresh token stored in the cookie.

Args:
    request (Request): The request containing the cookie.
    session (Annotated[Session, Depends(get_db)]): the database session.
    refresh_token (Annotated[Str | None, Cookie()]): the refresh
        token, which is fetched from a cookie included in the response.

Returns:
    dict: A dictionary containing the new access token.
 * @summary Refresh Access Token
 */
export const refreshAccessTokenRefreshPostResponse = zod.any();

/**
 * Add a new user of the role Decision Maker to the database. Requires no login.

Args:
    form_data (Annotated[OAuth2PasswordRequestForm, Depends()]): The user credentials to add to the database.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: A JSON response

Raises:
    HTTPException: if username is already in use or if saving to the database fails for some reason.
 * @summary Add New Dm
 */
export const addNewDmAddNewDmPostResponse = zod.any();

/**
 * Add a new user of the role Analyst to the database. Requires a logged in analyst or an admin.

Args:
    user: Annotated[User, Depends(get_current_user)]: Logged in user with the role "analyst" or "admin".
    form_data: (Annotated[OAuth2PasswordRequestForm, Depends()]): The user credentials to add to the database.
    session: (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: A JSON response

Raises:
    HTTPException: if the logged in user is not an analyst or an admin or if
    username is already in use or if saving to the database fails for some reason.
 * @summary Add New Analyst
 */
export const addNewAnalystAddNewAnalystPostResponse = zod.any();

/**
 * Get information on all the current user's problems.

Args:
    user (Annotated[User, Depends): the current user.

Returns:
    list[ProblemInfoSmall]: a list of information on all the problems.
 * @summary Get Problems
 */
export const getProblemsProblemAllGetResponseProblemMetadataForestMetadataItemMetadataTypeDefault =
	'forest_problem_metadata';
export const getProblemsProblemAllGetResponseProblemMetadataRepresentativeNdMetadataItemMetadataTypeDefault =
	'representative_non_dominated_solutions';

export const getProblemsProblemAllGetResponseItem = zod
	.object({
		name: zod.string(),
		description: zod.string(),
		is_convex: zod.union([zod.boolean(), zod.null()]),
		is_linear: zod.union([zod.boolean(), zod.null()]),
		is_twice_differentiable: zod.union([zod.boolean(), zod.null()]),
		scenario_keys: zod.union([zod.array(zod.string()), zod.null()]),
		variable_domain: zod
			.enum(['continuous', 'binary', 'integer', 'mixed'])
			.describe('An enumerator for the possible variable type domains of a problem.'),
		id: zod.number(),
		user_id: zod.number(),
		problem_metadata: zod.union([
			zod
				.object({
					problem_id: zod.number(),
					forest_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											getProblemsProblemAllGetResponseProblemMetadataForestMetadataItemMetadataTypeDefault
										),
									map_json: zod.string(),
									schedule_dict: zod.record(zod.string(), zod.any()),
									years: zod.array(zod.string()),
									stand_id_field: zod.string(),
									stand_descriptor: zod
										.union([zod.record(zod.string(), zod.any()), zod.null()])
										.optional(),
									compensation: zod.union([zod.number(), zod.null()]).optional()
								})
								.describe(
									'A problem metadata class to hold UTOPIA forest problem specific information.'
								)
						),
						zod.null()
					]),
					representative_nd_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											getProblemsProblemAllGetResponseProblemMetadataRepresentativeNdMetadataItemMetadataTypeDefault
										),
									name: zod.string().describe('The name of the representative set.'),
									description: zod
										.union([zod.string(), zod.null()])
										.optional()
										.describe('A description of the representative set. Optional.'),
									solution_data: zod
										.record(zod.string(), zod.array(zod.number()))
										.describe(
											'The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.'
										),
									ideal: zod
										.record(zod.string(), zod.number())
										.describe('The ideal objective function values of the representative set.'),
									nadir: zod
										.record(zod.string(), zod.number())
										.describe('The nadir objective function values of the representative set.')
								})
								.describe(
									'A problem metadata class to store representative solutions sets, i.e., non-dominated sets...\n\nA problem metadata class to store representative solutions sets, i.e., non-dominated sets that\nrepresent/approximate the Pareto optimal solution set of the problem.\n\nNote:\n    It is assumed that the solution set is non-dominated.'
								)
						),
						zod.null()
					])
				})
				.describe('Response model for ProblemMetaData.'),
			zod.null()
		])
	})
	.describe('Problem info request return data, but smaller.');
export const getProblemsProblemAllGetResponse = zod.array(getProblemsProblemAllGetResponseItem);

/**
 * Get detailed information on all the current user's problems.

Args:
    user (Annotated[User, Depends): the current user.

Returns:
    list[ProblemInfo]: a list of the detailed information on all the problems.
 * @summary Get Problems Info
 */
export const getProblemsInfoProblemAllInfoGetResponseObjectivesItemMaximizeDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseObjectivesItemIsLinearDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseObjectivesItemIsConvexDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseObjectivesItemIsTwiceDifferentiableDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseConstraintsItemIsLinearDefault = true;
export const getProblemsInfoProblemAllInfoGetResponseConstraintsItemIsConvexDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseConstraintsItemIsTwiceDifferentiableDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseScalarizationFuncsItemIsLinearDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseScalarizationFuncsItemIsConvexDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseScalarizationFuncsItemIsTwiceDifferentiableDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseExtraFuncsItemIsLinearDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseExtraFuncsItemIsConvexDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseExtraFuncsItemIsTwiceDifferentiableDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseDiscreteRepresentationNonDominatedDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseProblemMetadataForestMetadataItemMetadataTypeDefault =
	'forest_problem_metadata';
export const getProblemsInfoProblemAllInfoGetResponseProblemMetadataRepresentativeNdMetadataItemMetadataTypeDefault =
	'representative_non_dominated_solutions';

export const getProblemsInfoProblemAllInfoGetResponseItem = zod
	.object({
		name: zod.string(),
		description: zod.string(),
		is_convex: zod.union([zod.boolean(), zod.null()]),
		is_linear: zod.union([zod.boolean(), zod.null()]),
		is_twice_differentiable: zod.union([zod.boolean(), zod.null()]),
		scenario_keys: zod.union([zod.array(zod.string()), zod.null()]),
		variable_domain: zod
			.enum(['continuous', 'binary', 'integer', 'mixed'])
			.describe('An enumerator for the possible variable type domains of a problem.'),
		id: zod.number(),
		user_id: zod.number(),
		constants: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the constant. This can be used in UI and visualizations. Example: 'maximum cost'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'c_1'."
							),
						value: zod.number().describe('The value of the constant.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constant`.')
			),
			zod.null()
		]),
		tensor_constants: zod.union([
			zod.array(
				zod
					.object({
						values: zod.union([
							zod.array(zod.any()),
							zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.literal('List'),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the tensor representing the values. E.g., 'distances'"
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorConstant`.')
			),
			zod.null()
		]),
		variables: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'v_1'."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						lowerbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Lower bound of the variable.'),
						upperbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Upper bound of the variable.'),
						initial_value: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Initial value of the variable. This is optional.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Variable`.')
			),
			zod.null()
		]),
		tensor_variables: zod.union([
			zod.array(
				zod
					.object({
						initial_values: zod.union([
							zod.union([
								zod.array(zod.any()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						lowerbounds: zod.union([
							zod.union([
								zod.array(zod.any()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						upperbounds: zod.union([
							zod.union([
								zod.array(zod.any()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorVariable`.')
			),
			zod.null()
		]),
		objectives: zod.array(
			zod
				.object({
					func: zod.union([zod.array(zod.any()), zod.null()]),
					scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					simulator_path: zod
						.union([
							zod.string(),
							zod
								.object({
									url: zod
										.string()
										.describe(
											'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
										),
									auth: zod
										.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
										.optional()
										.describe(
											'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
										)
								})
								.describe('Model for a URL.'),
							zod.null()
						])
						.optional(),
					name: zod
						.string()
						.describe(
							"Descriptive name of the objective function. This can be used in UI and visualizations. Example: 'time'."
						),
					symbol: zod
						.string()
						.describe(
							"Symbol to represent the objective function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'f_1'."
						),
					unit: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							"The unit of the objective function. This is optional. Used in UIs and visualizations. Example: 'seconds' or 'millions of hectares'."
						),
					maximize: zod
						.boolean()
						.optional()
						.describe('Whether the objective function is to be maximized or minimized.'),
					ideal: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Ideal value of the objective. This is optional.'),
					nadir: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Nadir value of the objective. This is optional.'),
					objective_type: zod
						.enum(['analytical', 'data_based', 'simulator', 'surrogate'])
						.optional()
						.describe('An enumerator for supported objective function types.'),
					is_linear: zod
						.boolean()
						.optional()
						.describe('Whether the function expression is linear or not. Defaults to `False`.'),
					is_convex: zod
						.boolean()
						.optional()
						.describe(
							'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
						),
					is_twice_differentiable: zod
						.boolean()
						.optional()
						.describe(
							'Whether the function expression is twice differentiable or not. Defaults to `False`'
						),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `Objective`.')
		),
		constraints: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.any()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe(
								"Descriptive name of the constraint. This can be used in UI and visualizations. Example: 'maximum length'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constraint. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'g_1'."
							),
						cons_type: zod
							.enum(['=', '<='])
							.describe('An enumerator for supported constraint expression types.'),
						is_linear: zod
							.boolean()
							.default(getProblemsInfoProblemAllInfoGetResponseConstraintsItemIsLinearDefault)
							.describe(
								'Whether the constraint is linear or not. Defaults to True, e.g., a linear constraint is assumed.'
							),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constraint`.')
			),
			zod.null()
		]),
		scalarization_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.any()),
						scenario_keys: zod.array(zod.string()),
						name: zod.string().describe('Name of the scalarization function.'),
						symbol: zod
							.union([zod.string(), zod.null()])
							.optional()
							.describe(
								'Optional symbol to represent the scalarization function. This may be used in UIs and visualizations.'
							),
						is_linear: zod
							.boolean()
							.optional()
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ScalarizationFunction`.')
			),
			zod.null()
		]),
		extra_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.any()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe("Descriptive name of the function. Example: 'normalization'."),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'avg'."
							),
						is_linear: zod
							.boolean()
							.optional()
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ExtraFunction`.')
			),
			zod.null()
		]),
		discrete_representation: zod.union([
			zod
				.object({
					non_dominated: zod.boolean().optional(),
					variable_values: zod.record(
						zod.string(),
						zod.array(zod.union([zod.number(), zod.number(), zod.boolean()]))
					),
					objective_values: zod.record(zod.string(), zod.array(zod.number())),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `DiscreteRepresentation`.'),
			zod.null()
		]),
		simulators: zod.union([
			zod.array(
				zod
					.object({
						file: zod.union([zod.string(), zod.null()]).optional(),
						url: zod
							.union([
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						parameter_options: zod
							.union([zod.record(zod.string(), zod.any()), zod.null()])
							.optional(),
						name: zod
							.string()
							.describe(
								'Descriptive name of the simulator. This can be used in UI and visualizations.'
							),
						symbol: zod
							.string()
							.describe(
								'Symbol to represent the simulator. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations.'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Simulator`.')
			),
			zod.null()
		]),
		problem_metadata: zod.union([
			zod
				.object({
					problem_id: zod.number(),
					forest_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											getProblemsInfoProblemAllInfoGetResponseProblemMetadataForestMetadataItemMetadataTypeDefault
										),
									map_json: zod.string(),
									schedule_dict: zod.record(zod.string(), zod.any()),
									years: zod.array(zod.string()),
									stand_id_field: zod.string(),
									stand_descriptor: zod
										.union([zod.record(zod.string(), zod.any()), zod.null()])
										.optional(),
									compensation: zod.union([zod.number(), zod.null()]).optional()
								})
								.describe(
									'A problem metadata class to hold UTOPIA forest problem specific information.'
								)
						),
						zod.null()
					]),
					representative_nd_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											getProblemsInfoProblemAllInfoGetResponseProblemMetadataRepresentativeNdMetadataItemMetadataTypeDefault
										),
									name: zod.string().describe('The name of the representative set.'),
									description: zod
										.union([zod.string(), zod.null()])
										.optional()
										.describe('A description of the representative set. Optional.'),
									solution_data: zod
										.record(zod.string(), zod.array(zod.number()))
										.describe(
											'The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.'
										),
									ideal: zod
										.record(zod.string(), zod.number())
										.describe('The ideal objective function values of the representative set.'),
									nadir: zod
										.record(zod.string(), zod.number())
										.describe('The nadir objective function values of the representative set.')
								})
								.describe(
									'A problem metadata class to store representative solutions sets, i.e., non-dominated sets...\n\nA problem metadata class to store representative solutions sets, i.e., non-dominated sets that\nrepresent/approximate the Pareto optimal solution set of the problem.\n\nNote:\n    It is assumed that the solution set is non-dominated.'
								)
						),
						zod.null()
					])
				})
				.describe('Response model for ProblemMetaData.'),
			zod.null()
		])
	})
	.describe('Problem info request return data.');
export const getProblemsInfoProblemAllInfoGetResponse = zod.array(
	getProblemsInfoProblemAllInfoGetResponseItem
);

/**
 * Get the model of a specific problem.

Args:
    request (ProblemGetRequest): the request containing the problem's id `problem_id`.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): the database session.

Raises:
    HTTPException: could not find a problem with the given id.

Returns:
    ProblemInfo: detailed information on the requested problem.
 * @summary Get Problem
 */
export const getProblemProblemGetPostBody = zod
	.object({
		problem_id: zod.number()
	})
	.describe('Model to deal with problem fetching requests.');

export const getProblemProblemGetPostResponseObjectivesItemMaximizeDefault = false;
export const getProblemProblemGetPostResponseObjectivesItemIsLinearDefault = false;
export const getProblemProblemGetPostResponseObjectivesItemIsConvexDefault = false;
export const getProblemProblemGetPostResponseObjectivesItemIsTwiceDifferentiableDefault = false;
export const getProblemProblemGetPostResponseConstraintsItemIsLinearDefault = true;
export const getProblemProblemGetPostResponseConstraintsItemIsConvexDefault = false;
export const getProblemProblemGetPostResponseConstraintsItemIsTwiceDifferentiableDefault = false;
export const getProblemProblemGetPostResponseScalarizationFuncsItemIsLinearDefault = false;
export const getProblemProblemGetPostResponseScalarizationFuncsItemIsConvexDefault = false;
export const getProblemProblemGetPostResponseScalarizationFuncsItemIsTwiceDifferentiableDefault = false;
export const getProblemProblemGetPostResponseExtraFuncsItemIsLinearDefault = false;
export const getProblemProblemGetPostResponseExtraFuncsItemIsConvexDefault = false;
export const getProblemProblemGetPostResponseExtraFuncsItemIsTwiceDifferentiableDefault = false;
export const getProblemProblemGetPostResponseDiscreteRepresentationNonDominatedDefault = false;
export const getProblemProblemGetPostResponseProblemMetadataForestMetadataItemMetadataTypeDefault =
	'forest_problem_metadata';
export const getProblemProblemGetPostResponseProblemMetadataRepresentativeNdMetadataItemMetadataTypeDefault =
	'representative_non_dominated_solutions';

export const getProblemProblemGetPostResponse = zod
	.object({
		name: zod.string(),
		description: zod.string(),
		is_convex: zod.union([zod.boolean(), zod.null()]),
		is_linear: zod.union([zod.boolean(), zod.null()]),
		is_twice_differentiable: zod.union([zod.boolean(), zod.null()]),
		scenario_keys: zod.union([zod.array(zod.string()), zod.null()]),
		variable_domain: zod
			.enum(['continuous', 'binary', 'integer', 'mixed'])
			.describe('An enumerator for the possible variable type domains of a problem.'),
		id: zod.number(),
		user_id: zod.number(),
		constants: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the constant. This can be used in UI and visualizations. Example: 'maximum cost'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'c_1'."
							),
						value: zod.number().describe('The value of the constant.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constant`.')
			),
			zod.null()
		]),
		tensor_constants: zod.union([
			zod.array(
				zod
					.object({
						values: zod.union([
							zod.array(zod.any()),
							zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.literal('List'),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the tensor representing the values. E.g., 'distances'"
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorConstant`.')
			),
			zod.null()
		]),
		variables: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'v_1'."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						lowerbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Lower bound of the variable.'),
						upperbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Upper bound of the variable.'),
						initial_value: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Initial value of the variable. This is optional.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Variable`.')
			),
			zod.null()
		]),
		tensor_variables: zod.union([
			zod.array(
				zod
					.object({
						initial_values: zod.union([
							zod.union([
								zod.array(zod.any()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						lowerbounds: zod.union([
							zod.union([
								zod.array(zod.any()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						upperbounds: zod.union([
							zod.union([
								zod.array(zod.any()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorVariable`.')
			),
			zod.null()
		]),
		objectives: zod.array(
			zod
				.object({
					func: zod.union([zod.array(zod.any()), zod.null()]),
					scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					simulator_path: zod
						.union([
							zod.string(),
							zod
								.object({
									url: zod
										.string()
										.describe(
											'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
										),
									auth: zod
										.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
										.optional()
										.describe(
											'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
										)
								})
								.describe('Model for a URL.'),
							zod.null()
						])
						.optional(),
					name: zod
						.string()
						.describe(
							"Descriptive name of the objective function. This can be used in UI and visualizations. Example: 'time'."
						),
					symbol: zod
						.string()
						.describe(
							"Symbol to represent the objective function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'f_1'."
						),
					unit: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							"The unit of the objective function. This is optional. Used in UIs and visualizations. Example: 'seconds' or 'millions of hectares'."
						),
					maximize: zod
						.boolean()
						.optional()
						.describe('Whether the objective function is to be maximized or minimized.'),
					ideal: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Ideal value of the objective. This is optional.'),
					nadir: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Nadir value of the objective. This is optional.'),
					objective_type: zod
						.enum(['analytical', 'data_based', 'simulator', 'surrogate'])
						.optional()
						.describe('An enumerator for supported objective function types.'),
					is_linear: zod
						.boolean()
						.optional()
						.describe('Whether the function expression is linear or not. Defaults to `False`.'),
					is_convex: zod
						.boolean()
						.optional()
						.describe(
							'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
						),
					is_twice_differentiable: zod
						.boolean()
						.optional()
						.describe(
							'Whether the function expression is twice differentiable or not. Defaults to `False`'
						),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `Objective`.')
		),
		constraints: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.any()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe(
								"Descriptive name of the constraint. This can be used in UI and visualizations. Example: 'maximum length'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constraint. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'g_1'."
							),
						cons_type: zod
							.enum(['=', '<='])
							.describe('An enumerator for supported constraint expression types.'),
						is_linear: zod
							.boolean()
							.default(getProblemProblemGetPostResponseConstraintsItemIsLinearDefault)
							.describe(
								'Whether the constraint is linear or not. Defaults to True, e.g., a linear constraint is assumed.'
							),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constraint`.')
			),
			zod.null()
		]),
		scalarization_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.any()),
						scenario_keys: zod.array(zod.string()),
						name: zod.string().describe('Name of the scalarization function.'),
						symbol: zod
							.union([zod.string(), zod.null()])
							.optional()
							.describe(
								'Optional symbol to represent the scalarization function. This may be used in UIs and visualizations.'
							),
						is_linear: zod
							.boolean()
							.optional()
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ScalarizationFunction`.')
			),
			zod.null()
		]),
		extra_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.any()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe("Descriptive name of the function. Example: 'normalization'."),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'avg'."
							),
						is_linear: zod
							.boolean()
							.optional()
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ExtraFunction`.')
			),
			zod.null()
		]),
		discrete_representation: zod.union([
			zod
				.object({
					non_dominated: zod.boolean().optional(),
					variable_values: zod.record(
						zod.string(),
						zod.array(zod.union([zod.number(), zod.number(), zod.boolean()]))
					),
					objective_values: zod.record(zod.string(), zod.array(zod.number())),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `DiscreteRepresentation`.'),
			zod.null()
		]),
		simulators: zod.union([
			zod.array(
				zod
					.object({
						file: zod.union([zod.string(), zod.null()]).optional(),
						url: zod
							.union([
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						parameter_options: zod
							.union([zod.record(zod.string(), zod.any()), zod.null()])
							.optional(),
						name: zod
							.string()
							.describe(
								'Descriptive name of the simulator. This can be used in UI and visualizations.'
							),
						symbol: zod
							.string()
							.describe(
								'Symbol to represent the simulator. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations.'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Simulator`.')
			),
			zod.null()
		]),
		problem_metadata: zod.union([
			zod
				.object({
					problem_id: zod.number(),
					forest_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											getProblemProblemGetPostResponseProblemMetadataForestMetadataItemMetadataTypeDefault
										),
									map_json: zod.string(),
									schedule_dict: zod.record(zod.string(), zod.any()),
									years: zod.array(zod.string()),
									stand_id_field: zod.string(),
									stand_descriptor: zod
										.union([zod.record(zod.string(), zod.any()), zod.null()])
										.optional(),
									compensation: zod.union([zod.number(), zod.null()]).optional()
								})
								.describe(
									'A problem metadata class to hold UTOPIA forest problem specific information.'
								)
						),
						zod.null()
					]),
					representative_nd_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											getProblemProblemGetPostResponseProblemMetadataRepresentativeNdMetadataItemMetadataTypeDefault
										),
									name: zod.string().describe('The name of the representative set.'),
									description: zod
										.union([zod.string(), zod.null()])
										.optional()
										.describe('A description of the representative set. Optional.'),
									solution_data: zod
										.record(zod.string(), zod.array(zod.number()))
										.describe(
											'The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.'
										),
									ideal: zod
										.record(zod.string(), zod.number())
										.describe('The ideal objective function values of the representative set.'),
									nadir: zod
										.record(zod.string(), zod.number())
										.describe('The nadir objective function values of the representative set.')
								})
								.describe(
									'A problem metadata class to store representative solutions sets, i.e., non-dominated sets...\n\nA problem metadata class to store representative solutions sets, i.e., non-dominated sets that\nrepresent/approximate the Pareto optimal solution set of the problem.\n\nNote:\n    It is assumed that the solution set is non-dominated.'
								)
						),
						zod.null()
					])
				})
				.describe('Response model for ProblemMetaData.'),
			zod.null()
		])
	})
	.describe('Problem info request return data.');

/**
 * Add a newly defined problem to the database.

Args:
    request (Problem): the JSON representation of the problem.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): the database session.

Note:
    Users with the role 'guest' may not add new problems.

Raises:
    HTTPException: when any issue with defining the problem arises.

Returns:
    ProblemInfo: the information about the problem added.
 * @summary Add Problem
 */
export const addProblemProblemAddPostResponseObjectivesItemMaximizeDefault = false;
export const addProblemProblemAddPostResponseObjectivesItemIsLinearDefault = false;
export const addProblemProblemAddPostResponseObjectivesItemIsConvexDefault = false;
export const addProblemProblemAddPostResponseObjectivesItemIsTwiceDifferentiableDefault = false;
export const addProblemProblemAddPostResponseConstraintsItemIsLinearDefault = true;
export const addProblemProblemAddPostResponseConstraintsItemIsConvexDefault = false;
export const addProblemProblemAddPostResponseConstraintsItemIsTwiceDifferentiableDefault = false;
export const addProblemProblemAddPostResponseScalarizationFuncsItemIsLinearDefault = false;
export const addProblemProblemAddPostResponseScalarizationFuncsItemIsConvexDefault = false;
export const addProblemProblemAddPostResponseScalarizationFuncsItemIsTwiceDifferentiableDefault = false;
export const addProblemProblemAddPostResponseExtraFuncsItemIsLinearDefault = false;
export const addProblemProblemAddPostResponseExtraFuncsItemIsConvexDefault = false;
export const addProblemProblemAddPostResponseExtraFuncsItemIsTwiceDifferentiableDefault = false;
export const addProblemProblemAddPostResponseDiscreteRepresentationNonDominatedDefault = false;
export const addProblemProblemAddPostResponseProblemMetadataForestMetadataItemMetadataTypeDefault =
	'forest_problem_metadata';
export const addProblemProblemAddPostResponseProblemMetadataRepresentativeNdMetadataItemMetadataTypeDefault =
	'representative_non_dominated_solutions';

export const addProblemProblemAddPostResponse = zod
	.object({
		name: zod.string(),
		description: zod.string(),
		is_convex: zod.union([zod.boolean(), zod.null()]),
		is_linear: zod.union([zod.boolean(), zod.null()]),
		is_twice_differentiable: zod.union([zod.boolean(), zod.null()]),
		scenario_keys: zod.union([zod.array(zod.string()), zod.null()]),
		variable_domain: zod
			.enum(['continuous', 'binary', 'integer', 'mixed'])
			.describe('An enumerator for the possible variable type domains of a problem.'),
		id: zod.number(),
		user_id: zod.number(),
		constants: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the constant. This can be used in UI and visualizations. Example: 'maximum cost'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'c_1'."
							),
						value: zod.number().describe('The value of the constant.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constant`.')
			),
			zod.null()
		]),
		tensor_constants: zod.union([
			zod.array(
				zod
					.object({
						values: zod.union([
							zod.array(zod.any()),
							zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.literal('List'),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the tensor representing the values. E.g., 'distances'"
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorConstant`.')
			),
			zod.null()
		]),
		variables: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'v_1'."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						lowerbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Lower bound of the variable.'),
						upperbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Upper bound of the variable.'),
						initial_value: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Initial value of the variable. This is optional.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Variable`.')
			),
			zod.null()
		]),
		tensor_variables: zod.union([
			zod.array(
				zod
					.object({
						initial_values: zod.union([
							zod.union([
								zod.array(zod.any()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						lowerbounds: zod.union([
							zod.union([
								zod.array(zod.any()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						upperbounds: zod.union([
							zod.union([
								zod.array(zod.any()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorVariable`.')
			),
			zod.null()
		]),
		objectives: zod.array(
			zod
				.object({
					func: zod.union([zod.array(zod.any()), zod.null()]),
					scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					simulator_path: zod
						.union([
							zod.string(),
							zod
								.object({
									url: zod
										.string()
										.describe(
											'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
										),
									auth: zod
										.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
										.optional()
										.describe(
											'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
										)
								})
								.describe('Model for a URL.'),
							zod.null()
						])
						.optional(),
					name: zod
						.string()
						.describe(
							"Descriptive name of the objective function. This can be used in UI and visualizations. Example: 'time'."
						),
					symbol: zod
						.string()
						.describe(
							"Symbol to represent the objective function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'f_1'."
						),
					unit: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							"The unit of the objective function. This is optional. Used in UIs and visualizations. Example: 'seconds' or 'millions of hectares'."
						),
					maximize: zod
						.boolean()
						.optional()
						.describe('Whether the objective function is to be maximized or minimized.'),
					ideal: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Ideal value of the objective. This is optional.'),
					nadir: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Nadir value of the objective. This is optional.'),
					objective_type: zod
						.enum(['analytical', 'data_based', 'simulator', 'surrogate'])
						.optional()
						.describe('An enumerator for supported objective function types.'),
					is_linear: zod
						.boolean()
						.optional()
						.describe('Whether the function expression is linear or not. Defaults to `False`.'),
					is_convex: zod
						.boolean()
						.optional()
						.describe(
							'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
						),
					is_twice_differentiable: zod
						.boolean()
						.optional()
						.describe(
							'Whether the function expression is twice differentiable or not. Defaults to `False`'
						),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `Objective`.')
		),
		constraints: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.any()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe(
								"Descriptive name of the constraint. This can be used in UI and visualizations. Example: 'maximum length'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constraint. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'g_1'."
							),
						cons_type: zod
							.enum(['=', '<='])
							.describe('An enumerator for supported constraint expression types.'),
						is_linear: zod
							.boolean()
							.default(addProblemProblemAddPostResponseConstraintsItemIsLinearDefault)
							.describe(
								'Whether the constraint is linear or not. Defaults to True, e.g., a linear constraint is assumed.'
							),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constraint`.')
			),
			zod.null()
		]),
		scalarization_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.any()),
						scenario_keys: zod.array(zod.string()),
						name: zod.string().describe('Name of the scalarization function.'),
						symbol: zod
							.union([zod.string(), zod.null()])
							.optional()
							.describe(
								'Optional symbol to represent the scalarization function. This may be used in UIs and visualizations.'
							),
						is_linear: zod
							.boolean()
							.optional()
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ScalarizationFunction`.')
			),
			zod.null()
		]),
		extra_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.any()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe("Descriptive name of the function. Example: 'normalization'."),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'avg'."
							),
						is_linear: zod
							.boolean()
							.optional()
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ExtraFunction`.')
			),
			zod.null()
		]),
		discrete_representation: zod.union([
			zod
				.object({
					non_dominated: zod.boolean().optional(),
					variable_values: zod.record(
						zod.string(),
						zod.array(zod.union([zod.number(), zod.number(), zod.boolean()]))
					),
					objective_values: zod.record(zod.string(), zod.array(zod.number())),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `DiscreteRepresentation`.'),
			zod.null()
		]),
		simulators: zod.union([
			zod.array(
				zod
					.object({
						file: zod.union([zod.string(), zod.null()]).optional(),
						url: zod
							.union([
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						parameter_options: zod
							.union([zod.record(zod.string(), zod.any()), zod.null()])
							.optional(),
						name: zod
							.string()
							.describe(
								'Descriptive name of the simulator. This can be used in UI and visualizations.'
							),
						symbol: zod
							.string()
							.describe(
								'Symbol to represent the simulator. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations.'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Simulator`.')
			),
			zod.null()
		]),
		problem_metadata: zod.union([
			zod
				.object({
					problem_id: zod.number(),
					forest_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											addProblemProblemAddPostResponseProblemMetadataForestMetadataItemMetadataTypeDefault
										),
									map_json: zod.string(),
									schedule_dict: zod.record(zod.string(), zod.any()),
									years: zod.array(zod.string()),
									stand_id_field: zod.string(),
									stand_descriptor: zod
										.union([zod.record(zod.string(), zod.any()), zod.null()])
										.optional(),
									compensation: zod.union([zod.number(), zod.null()]).optional()
								})
								.describe(
									'A problem metadata class to hold UTOPIA forest problem specific information.'
								)
						),
						zod.null()
					]),
					representative_nd_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											addProblemProblemAddPostResponseProblemMetadataRepresentativeNdMetadataItemMetadataTypeDefault
										),
									name: zod.string().describe('The name of the representative set.'),
									description: zod
										.union([zod.string(), zod.null()])
										.optional()
										.describe('A description of the representative set. Optional.'),
									solution_data: zod
										.record(zod.string(), zod.array(zod.number()))
										.describe(
											'The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.'
										),
									ideal: zod
										.record(zod.string(), zod.number())
										.describe('The ideal objective function values of the representative set.'),
									nadir: zod
										.record(zod.string(), zod.number())
										.describe('The nadir objective function values of the representative set.')
								})
								.describe(
									'A problem metadata class to store representative solutions sets, i.e., non-dominated sets...\n\nA problem metadata class to store representative solutions sets, i.e., non-dominated sets that\nrepresent/approximate the Pareto optimal solution set of the problem.\n\nNote:\n    It is assumed that the solution set is non-dominated.'
								)
						),
						zod.null()
					])
				})
				.describe('Response model for ProblemMetaData.'),
			zod.null()
		])
	})
	.describe('Problem info request return data.');

/**
 * Fetch specific metadata for a specific problem.

Fetch specific metadata for a specific problem. See all the possible
metadata types from DESDEO/desdeo/api/models/problem.py Problem Metadata
section.

Args:
    request (MetaDataGetRequest): the requested metadata type.
    user (Annotated[User, Depends]): the current user.
    session (Annotated[Session, Depends]): the database session.

Returns:
    list[ForestProblemMetadata | RepresentativeNonDominatedSolutions]: list containing all the metadata
        defined for the problem with the requested metadata type. If no match is found,
        returns an empty list.
 * @summary Get Metadata
 */
export const getMetadataProblemGetMetadataPostBody = zod
	.object({
		problem_id: zod.number(),
		metadata_type: zod.string()
	})
	.describe('Request model for getting specific type of metadata from a specific problem.');

export const getMetadataProblemGetMetadataPostResponseMetadataTypeDefault =
	'forest_problem_metadata';
export const getMetadataProblemGetMetadataPostResponseMetadataTypeDefaultOne =
	'representative_non_dominated_solutions';
export const getMetadataProblemGetMetadataPostResponseMetadataTypeDefaultTwo =
	'solver_selection_metadata';

export const getMetadataProblemGetMetadataPostResponseItem = zod.union([
	zod
		.object({
			id: zod.union([zod.number(), zod.null()]).optional(),
			metadata_id: zod.union([zod.number(), zod.null()]).optional(),
			metadata_type: zod
				.string()
				.default(getMetadataProblemGetMetadataPostResponseMetadataTypeDefault),
			map_json: zod.string(),
			schedule_dict: zod.record(zod.string(), zod.any()),
			years: zod.array(zod.string()),
			stand_id_field: zod.string(),
			stand_descriptor: zod.union([zod.record(zod.string(), zod.any()), zod.null()]).optional(),
			compensation: zod.union([zod.number(), zod.null()]).optional()
		})
		.describe('A problem metadata class to hold UTOPIA forest problem specific information.'),
	zod
		.object({
			id: zod.union([zod.number(), zod.null()]).optional(),
			metadata_id: zod.union([zod.number(), zod.null()]).optional(),
			metadata_type: zod
				.string()
				.default(getMetadataProblemGetMetadataPostResponseMetadataTypeDefaultOne),
			name: zod.string().describe('The name of the representative set.'),
			description: zod
				.union([zod.string(), zod.null()])
				.optional()
				.describe('A description of the representative set. Optional.'),
			solution_data: zod
				.record(zod.string(), zod.array(zod.number()))
				.describe(
					'The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.'
				),
			ideal: zod
				.record(zod.string(), zod.number())
				.describe('The ideal objective function values of the representative set.'),
			nadir: zod
				.record(zod.string(), zod.number())
				.describe('The nadir objective function values of the representative set.')
		})
		.describe(
			'A problem metadata class to store representative solutions sets, i.e., non-dominated sets...\n\nA problem metadata class to store representative solutions sets, i.e., non-dominated sets that\nrepresent/approximate the Pareto optimal solution set of the problem.\n\nNote:\n    It is assumed that the solution set is non-dominated.'
		),
	zod
		.object({
			id: zod.union([zod.number(), zod.null()]).optional(),
			metadata_id: zod.union([zod.number(), zod.null()]).optional(),
			metadata_type: zod
				.string()
				.default(getMetadataProblemGetMetadataPostResponseMetadataTypeDefaultTwo),
			solver_string_representation: zod
				.string()
				.describe('The string representation of the selected solver.')
		})
		.describe(
			'A problem metadata class to store the preferred solver of a problem.\n\nA problem metadata class to store the preferred solver of a problem.\nSee desdeo/tools/utils.py -> available_solvers for available solvers.'
		)
]);
export const getMetadataProblemGetMetadataPostResponse = zod.array(
	getMetadataProblemGetMetadataPostResponseItem
);

/**
 * @summary Select Solver
 */
export const selectSolverProblemAssignSolverPostBody = zod
	.object({
		problem_id: zod.number(),
		solver_string_representation: zod.string()
	})
	.describe('Model to request a specific solver for a problem.');

export const selectSolverProblemAssignSolverPostResponse = zod.any();

/**
 * .
 * @summary Create New Session
 */
export const createNewSessionSessionNewPostBody = zod
	.object({
		info: zod.union([zod.string(), zod.null()]).optional()
	})
	.describe('Model of the request to create a new session.');

export const createNewSessionSessionNewPostResponse = zod
	.object({
		id: zod.union([zod.number(), zod.null()]),
		user_id: zod.union([zod.number(), zod.null()]),
		info: zod.union([zod.string(), zod.null()])
	})
	.describe('The base model for representing interactive sessions.');

/**
 * Return an interactive session with a given id for the current user.

Args:
    request (GetSessionRequest): a request containing the id of the session.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): the database session.

Raises:
    HTTPException: could not find an interactive session with the given id
        for the current user.

Returns:
    InteractiveSessionInfo: info on the requested interactive session.
 * @summary Get Session
 */
export const getSessionSessionGetPostBody = zod
	.object({
		session_id: zod.number()
	})
	.describe('Model of the request to get a specific session.');

export const getSessionSessionGetPostResponse = zod
	.object({
		id: zod.union([zod.number(), zod.null()]),
		user_id: zod.union([zod.number(), zod.null()]),
		info: zod.union([zod.string(), zod.null()])
	})
	.describe('The base model for representing interactive sessions.');

/**
 * Runs an iteration of the reference point method.

Args:
    request (RPMSolveRequest): a request with the needed information to run the method.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): the current database session.

Returns:
    RPMState: a state with information on the results of iterating the reference point method
        once.
 * @summary Solve Solutions
 */
export const solveSolutionsMethodRpmSolvePostBodyPreferencePreferenceTypeDefault =
	'reference_point';

export const solveSolutionsMethodRpmSolvePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		preference: zod
			.object({
				preference_type: zod
					.literal('reference_point')
					.default(solveSolutionsMethodRpmSolvePostBodyPreferencePreferenceTypeDefault),
				aspiration_levels: zod.record(zod.string(), zod.number())
			})
			.optional()
			.describe('Model for representing a reference point type of preference.')
	})
	.describe('Model of the request to the reference point method.');

export const solveSolutionsMethodRpmSolvePostResponsePreferencesPreferenceTypeDefault =
	'reference_point';

export const solveSolutionsMethodRpmSolvePostResponse = zod
	.object({
		id: zod.union([zod.number(), zod.null()]).optional(),
		preferences: zod
			.object({
				preference_type: zod
					.literal('reference_point')
					.default(solveSolutionsMethodRpmSolvePostResponsePreferencesPreferenceTypeDefault),
				aspiration_levels: zod.record(zod.string(), zod.number())
			})
			.describe('Model for representing a reference point type of preference.'),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver_results: zod.array(
			zod
				.object({
					optimal_variables: zod
						.record(zod.string(), zod.union([zod.number(), zod.number(), zod.array(zod.any())]))
						.describe('The optimal decision variables found.'),
					optimal_objectives: zod
						.record(zod.string(), zod.union([zod.number(), zod.array(zod.number())]))
						.describe(
							'The objective function values corresponding to the optimal decision variables found.'
						),
					constraint_values: zod
						.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.array(zod.number()),
									zod.array(zod.any())
								])
							),
							zod.any(),
							zod.null()
						])
						.optional()
						.describe(
							'The constraint values of the problem. A negative value means the constraint is respected, a positive one means it has been breached.'
						),
					extra_func_values: zod
						.union([
							zod.record(zod.string(), zod.union([zod.number(), zod.array(zod.number())])),
							zod.null()
						])
						.optional()
						.describe('The extra function values of the problem.'),
					scalarization_values: zod
						.union([
							zod.record(zod.string(), zod.union([zod.number(), zod.array(zod.number())])),
							zod.null()
						])
						.optional()
						.describe('The scalarization function values of the problem.'),
					success: zod
						.boolean()
						.describe('A boolean flag indicating whether the optimization was successful or not.'),
					message: zod.string().describe('Description of the cause of termination.')
				})
				.describe('Defines a schema for a dataclass to store the results of a solver.')
		)
	})
	.describe('Reference Point Method (k+1 candidates).');

/**
 * Solve the problem using the NIMBUS method.
 * @summary Solve Solutions
 */
export const solveSolutionsMethodNimbusSolvePostBodyPreferencePreferenceTypeDefault =
	'reference_point';
export const solveSolutionsMethodNimbusSolvePostBodyNumDesiredDefault = 1;

export const solveSolutionsMethodNimbusSolvePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		preference: zod
			.object({
				preference_type: zod
					.literal('reference_point')
					.default(solveSolutionsMethodNimbusSolvePostBodyPreferencePreferenceTypeDefault),
				aspiration_levels: zod.record(zod.string(), zod.number())
			})
			.optional()
			.describe('Model for representing a reference point type of preference.'),
		current_objectives: zod
			.record(zod.string(), zod.number())
			.describe('The objectives used for iteration.'),
		num_desired: zod
			.union([zod.number(), zod.null()])
			.default(solveSolutionsMethodNimbusSolvePostBodyNumDesiredDefault)
	})
	.describe('Model of the request to the nimbus method.');

export const solveSolutionsMethodNimbusSolvePostResponsePreviousPreferencePreferenceTypeDefault =
	'reference_point';

export const solveSolutionsMethodNimbusSolvePostResponse = zod
	.object({
		state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
		previous_preference: zod
			.object({
				preference_type: zod
					.literal('reference_point')
					.default(
						solveSolutionsMethodNimbusSolvePostResponsePreviousPreferencePreferenceTypeDefault
					),
				aspiration_levels: zod.record(zod.string(), zod.number())
			})
			.describe('Model for representing a reference point type of preference.'),
		previous_objectives: zod
			.record(zod.string(), zod.number())
			.describe('The previous solutions objectives used for iteration.'),
		current_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.any()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The solutions from the current iteration of nimbus.'),
		saved_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.any()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The best candidate solutions saved by the decision maker.'),
		all_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.any()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('All solutions generated by NIMBUS in all iterations.')
	})
	.describe('The response from NIMBUS classification endpoint.');

/**
 * Initialize the problem for the NIMBUS method.
 * @summary Initialize
 */
export const initializeMethodNimbusInitializePostBodyStartingPointPreferenceTypeDefault =
	'reference_point';

export const initializeMethodNimbusInitializePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		starting_point: zod
			.union([
				zod
					.object({
						preference_type: zod
							.literal('reference_point')
							.default(initializeMethodNimbusInitializePostBodyStartingPointPreferenceTypeDefault),
						aspiration_levels: zod.record(zod.string(), zod.number())
					})
					.describe('Model for representing a reference point type of preference.'),
				zod
					.object({
						state_id: zod.number(),
						solution_index: zod.number(),
						name: zod
							.union([zod.string(), zod.null()])
							.optional()
							.describe('Name to be given to the solution. Optional.')
					})
					.describe(
						'Used when we wish to reference a solution in some `StateDB` stored in the database.'
					),
				zod.null()
			])
			.optional(),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional()
	})
	.describe('Model of the request to the nimbus method.');

export const initializeMethodNimbusInitializePostResponse = zod
	.object({
		state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
		current_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.any()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The solutions from the current interation of nimbus.'),
		saved_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.any()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The best candidate solutions saved by the decision maker.'),
		all_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.any()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('All solutions generated by NIMBUS in all iterations.')
	})
	.describe('The response from NIMBUS classification endpoint.');

/**
 * Save solutions.
 * @summary Save
 */
export const saveMethodNimbusSavePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		solution_info: zod.array(
			zod
				.object({
					state_id: zod.number(),
					solution_index: zod.number(),
					name: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe('Name to be given to the solution. Optional.')
				})
				.describe(
					'Used when we wish to reference a solution in some `StateDB` stored in the database.'
				)
		)
	})
	.describe("Request model for saving solutions from any method's state.");

export const saveMethodNimbusSavePostResponse = zod
	.object({
		state_id: zod.union([zod.number(), zod.null()]).describe('The id of the newest state')
	})
	.describe('The response from NIMBUS save endpoint.');

/**
 * Solve intermediate solutions by forwarding the request to generic intermediate endpoint with context nimbus.
 * @summary Solve Nimbus Intermediate
 */
export const solveNimbusIntermediateMethodNimbusIntermediatePostBodyNumDesiredDefault = 1;

export const solveNimbusIntermediateMethodNimbusIntermediatePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		context: zod.union([zod.string(), zod.null()]).optional(),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		num_desired: zod
			.union([zod.number(), zod.null()])
			.default(solveNimbusIntermediateMethodNimbusIntermediatePostBodyNumDesiredDefault),
		reference_solution_1: zod
			.object({
				state_id: zod.number(),
				solution_index: zod.number(),
				name: zod
					.union([zod.string(), zod.null()])
					.optional()
					.describe('Name to be given to the solution. Optional.')
			})
			.describe(
				'Used when we wish to reference a solution in some `StateDB` stored in the database.'
			),
		reference_solution_2: zod
			.object({
				state_id: zod.number(),
				solution_index: zod.number(),
				name: zod
					.union([zod.string(), zod.null()])
					.optional()
					.describe('Name to be given to the solution. Optional.')
			})
			.describe(
				'Used when we wish to reference a solution in some `StateDB` stored in the database.'
			)
	})
	.describe('Model of the request to solve intermediate solutions between two solutions.');

export const solveNimbusIntermediateMethodNimbusIntermediatePostResponse = zod
	.object({
		state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
		reference_solution_1: zod
			.record(zod.string(), zod.number())
			.describe('The first solution used when computing intermediate points.'),
		reference_solution_2: zod
			.record(zod.string(), zod.number())
			.describe('The second solution used when computing intermediate points.'),
		current_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.any()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The solutions from the current iteration of NIMBUS.'),
		saved_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.any()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The best candidate solutions saved by the decision maker.'),
		all_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.any()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('All solutions generated by NIMBUS in all iterations.')
	})
	.describe('The response from NIMBUS classification endpoint.');

/**
 * Get the latest NIMBUS state if it exists, or initialize a new one if it doesn't.
 * @summary Get Or Initialize
 */
export const getOrInitializeMethodNimbusGetOrInitializePostBodyStartingPointPreferenceTypeDefault =
	'reference_point';

export const getOrInitializeMethodNimbusGetOrInitializePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		starting_point: zod
			.union([
				zod
					.object({
						preference_type: zod
							.literal('reference_point')
							.default(
								getOrInitializeMethodNimbusGetOrInitializePostBodyStartingPointPreferenceTypeDefault
							),
						aspiration_levels: zod.record(zod.string(), zod.number())
					})
					.describe('Model for representing a reference point type of preference.'),
				zod
					.object({
						state_id: zod.number(),
						solution_index: zod.number(),
						name: zod
							.union([zod.string(), zod.null()])
							.optional()
							.describe('Name to be given to the solution. Optional.')
					})
					.describe(
						'Used when we wish to reference a solution in some `StateDB` stored in the database.'
					),
				zod.null()
			])
			.optional(),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional()
	})
	.describe('Model of the request to the nimbus method.');

export const getOrInitializeMethodNimbusGetOrInitializePostResponsePreviousPreferencePreferenceTypeDefault =
	'reference_point';

export const getOrInitializeMethodNimbusGetOrInitializePostResponse = zod.union([
	zod
		.object({
			state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
			current_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.any()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The solutions from the current interation of nimbus.'),
			saved_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.any()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The best candidate solutions saved by the decision maker.'),
			all_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.any()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('All solutions generated by NIMBUS in all iterations.')
		})
		.describe('The response from NIMBUS classification endpoint.'),
	zod
		.object({
			state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
			previous_preference: zod
				.object({
					preference_type: zod
						.literal('reference_point')
						.default(
							getOrInitializeMethodNimbusGetOrInitializePostResponsePreviousPreferencePreferenceTypeDefault
						),
					aspiration_levels: zod.record(zod.string(), zod.number())
				})
				.describe('Model for representing a reference point type of preference.'),
			previous_objectives: zod
				.record(zod.string(), zod.number())
				.describe('The previous solutions objectives used for iteration.'),
			current_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.any()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The solutions from the current iteration of nimbus.'),
			saved_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.any()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The best candidate solutions saved by the decision maker.'),
			all_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.any()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('All solutions generated by NIMBUS in all iterations.')
		})
		.describe('The response from NIMBUS classification endpoint.'),
	zod
		.object({
			state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
			reference_solution_1: zod
				.record(zod.string(), zod.number())
				.describe('The first solution used when computing intermediate points.'),
			reference_solution_2: zod
				.record(zod.string(), zod.number())
				.describe('The second solution used when computing intermediate points.'),
			current_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.any()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The solutions from the current iteration of NIMBUS.'),
			saved_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.any()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The best candidate solutions saved by the decision maker.'),
			all_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.any()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('All solutions generated by NIMBUS in all iterations.')
		})
		.describe('The response from NIMBUS classification endpoint.')
]);

/**
 * Solve intermediate solutions between given two solutions.
 * @summary Solve Intermediate
 */
export const solveIntermediateMethodGenericIntermediatePostBodyNumDesiredDefault = 1;

export const solveIntermediateMethodGenericIntermediatePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		context: zod.union([zod.string(), zod.null()]).optional(),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		num_desired: zod
			.union([zod.number(), zod.null()])
			.default(solveIntermediateMethodGenericIntermediatePostBodyNumDesiredDefault),
		reference_solution_1: zod
			.object({
				state_id: zod.number(),
				solution_index: zod.number(),
				name: zod
					.union([zod.string(), zod.null()])
					.optional()
					.describe('Name to be given to the solution. Optional.')
			})
			.describe(
				'Used when we wish to reference a solution in some `StateDB` stored in the database.'
			),
		reference_solution_2: zod
			.object({
				state_id: zod.number(),
				solution_index: zod.number(),
				name: zod
					.union([zod.string(), zod.null()])
					.optional()
					.describe('Name to be given to the solution. Optional.')
			})
			.describe(
				'Used when we wish to reference a solution in some `StateDB` stored in the database.'
			)
	})
	.describe('Model of the request to solve intermediate solutions between two solutions.');

export const solveIntermediateMethodGenericIntermediatePostResponse = zod
	.object({
		state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
		reference_solution_1: zod
			.object({
				name: zod.union([zod.string(), zod.null()]),
				solution_index: zod.union([zod.number(), zod.null()]),
				state_id: zod.number(),
				objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
				variable_values: zod.union([
					zod.record(
						zod.string(),
						zod.union([
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.union([
								zod.array(zod.any()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							])
						])
					),
					zod.null()
				])
			})
			.describe(
				'The response information provided when `SolutionReference` object are returned from the client.'
			),
		reference_solution_2: zod
			.object({
				name: zod.union([zod.string(), zod.null()]),
				solution_index: zod.union([zod.number(), zod.null()]),
				state_id: zod.number(),
				objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
				variable_values: zod.union([
					zod.record(
						zod.string(),
						zod.union([
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.union([
								zod.array(zod.any()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							])
						])
					),
					zod.null()
				])
			})
			.describe(
				'The response information provided when `SolutionReference` object are returned from the client.'
			),
		intermediate_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.any()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The intermediate solutions computed.')
	})
	.describe('The response from computing intermediate values.');

/**
 * Calculate SCORE bands parameters from objective data.
 * @summary Calculate Score Bands
 */
export const calculateScoreBandsMethodGenericScoreBandsPostBodyDistParameterDefault = 0.05;
export const calculateScoreBandsMethodGenericScoreBandsPostBodyUseAbsoluteCorrDefault = false;
export const calculateScoreBandsMethodGenericScoreBandsPostBodyDistanceFormulaDefault = 1;
export const calculateScoreBandsMethodGenericScoreBandsPostBodyFlipAxesDefault = true;
export const calculateScoreBandsMethodGenericScoreBandsPostBodyClusteringAlgorithmDefault =
	'DBSCAN';
export const calculateScoreBandsMethodGenericScoreBandsPostBodyClusteringScoreDefault = 'silhoutte';

export const calculateScoreBandsMethodGenericScoreBandsPostBody = zod
	.object({
		data: zod.array(zod.array(zod.number())).describe('Matrix of objective values'),
		objs: zod.array(zod.string()).describe('Array of objective names for each column'),
		dist_parameter: zod
			.number()
			.default(calculateScoreBandsMethodGenericScoreBandsPostBodyDistParameterDefault)
			.describe('Distance parameter for axis positioning'),
		use_absolute_corr: zod.boolean().optional().describe('Use absolute correlation values'),
		distance_formula: zod
			.number()
			.default(calculateScoreBandsMethodGenericScoreBandsPostBodyDistanceFormulaDefault)
			.describe('Distance formula (1 or 2)'),
		flip_axes: zod
			.boolean()
			.default(calculateScoreBandsMethodGenericScoreBandsPostBodyFlipAxesDefault)
			.describe('Whether to flip axes based on correlation signs'),
		clustering_algorithm: zod
			.string()
			.default(calculateScoreBandsMethodGenericScoreBandsPostBodyClusteringAlgorithmDefault)
			.describe('Clustering algorithm (DBSCAN or GMM)'),
		clustering_score: zod
			.string()
			.default(calculateScoreBandsMethodGenericScoreBandsPostBodyClusteringScoreDefault)
			.describe('Clustering score metric')
	})
	.describe('Model of the request to calculate SCORE bands parameters.');

export const calculateScoreBandsMethodGenericScoreBandsPostResponse = zod
	.object({
		groups: zod.array(zod.number()).describe('Cluster group assignments for each data point'),
		axis_dist: zod.array(zod.number()).describe('Normalized axis positions'),
		axis_signs: zod
			.union([zod.array(zod.number()), zod.null()])
			.describe('Axis direction signs (1 or -1)'),
		obj_order: zod.array(zod.number()).describe('Optimal order of objectives')
	})
	.describe('Model of the response containing SCORE bands parameters.');

/**
 * Request and receive the Utopia map corresponding to the decision variables sent. Can be just the optimal_variables form a SolverResult.

Args:
    request (UtopiaRequest): the set of decision variables and problem for which the utopia forest map is requested for.
    user (Annotated[User, Depend(get_current_user)]) the current user
    session (Annotated[Session, Depends(get_session)]) the current database session
Raises:
    HTTPException:
Returns:
    UtopiaResponse: the map for the forest, to be rendered in frontend
 * @summary Get Utopia Data
 */
export const getUtopiaDataUtopiaPostBody = zod
	.object({
		problem_id: zod.number().describe('Problem for which the map is generated'),
		solution: zod
			.object({
				state_id: zod.number(),
				solution_index: zod.number(),
				name: zod
					.union([zod.string(), zod.null()])
					.optional()
					.describe('Name to be given to the solution. Optional.')
			})
			.describe(
				'Used when we wish to reference a solution in some `StateDB` stored in the database.'
			)
	})
	.describe('The request for an Utopia map.');

export const getUtopiaDataUtopiaPostResponse = zod
	.object({
		is_utopia: zod.boolean().describe('True if map exists for this problem.'),
		map_name: zod.string().describe('Name of the map.'),
		map_json: zod
			.record(zod.string(), zod.any())
			.describe('MapJSON representation of the geography.'),
		options: zod
			.record(zod.string(), zod.any())
			.describe('A dict with given years as keys containing options for each year.'),
		description: zod.string().describe('Description shown above the map.'),
		years: zod
			.array(zod.string())
			.describe('A list of years for which the maps have been generated.')
	})
	.describe('The response to an UtopiaRequest.');

/**
 * Initialize the problem for NIMBUS

Different initializations should be used for different methods
 * @summary Gnimbus Initialize
 */
export const gnimbusInitializeGnimbusInitializePostBody = zod.object({
	group_id: zod.number()
});

export const gnimbusInitializeGnimbusInitializePostResponse = zod.any();

/**
 * Get the latest results from group iteration
NOTE: This function is likely obsolete as full_iterations does what it does ans more.

Args:
    request (GroupInfoRequest): essentially just the ID of the group
    user (Annotated[User, Depends(get_current_user)]): current user
    session (Annotated[Session, Depends(get_session)])

Returns:
    GNIMBUSResultResponse: A GNIMBUSResultResponse response containing the latest gnimbus results

Raises:
    HTTPException: Validation errors or no results
 * @summary Get Latest Results
 */
export const getLatestResultsGnimbusGetLatestResultsPostBody = zod.object({
	group_id: zod.number()
});

export const getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesMethodDefault = 'voting';
export const getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesMethodDefaultOne =
	'optimization';
export const getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesPhaseDefault =
	'learning';
export const getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesSetPreferencesPreferenceTypeDefault =
	'reference_point';

export const getLatestResultsGnimbusGetLatestResultsPostResponse = zod
	.object({
		method: zod.string(),
		phase: zod.string(),
		preferences: zod.union([
			zod
				.object({
					method: zod
						.string()
						.default(getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesMethodDefault),
					set_preferences: zod.record(zod.string(), zod.number())
				})
				.describe('Voting preferences'),
			zod
				.object({
					method: zod
						.string()
						.default(
							getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesMethodDefaultOne
						),
					phase: zod
						.string()
						.default(getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesPhaseDefault),
					set_preferences: zod.record(
						zod.string(),
						zod
							.object({
								preference_type: zod
									.literal('reference_point')
									.default(
										getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesSetPreferencesPreferenceTypeDefault
									),
								aspiration_levels: zod.record(zod.string(), zod.number())
							})
							.describe('Model for representing a reference point type of preference.')
					)
				})
				.describe(
					'An optimization preference class. As for the method and phase, see GNIMBUS for details.'
				)
		]),
		common_results: zod.array(
			zod
				.object({
					name: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe('Optional name to help identify the solution if, e.g., saved.'),
					solution_index: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe(
							'The index of the referenced solution, if multiple solutions exist in the reference state.'
						),
					state: zod
						.object({
							id: zod.union([zod.number(), zod.null()]).optional(),
							problem_id: zod.union([zod.number(), zod.null()]).optional(),
							session_id: zod.union([zod.number(), zod.null()]).optional(),
							parent_id: zod.union([zod.number(), zod.null()]).optional(),
							state_id: zod.union([zod.number(), zod.null()]).optional()
						})
						.describe('State holder with a single relationship to the base State.'),
					objective_values_all: zod.array(zod.record(zod.string(), zod.number())),
					variable_values_all: zod.array(
						zod.record(
							zod.string(),
							zod.union([
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.union([
									zod.array(zod.any()),
									zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.literal('List'),
									zod.null()
								])
							])
						)
					),
					objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
					variable_values: zod.union([
						zod.record(zod.string(), zod.union([zod.number(), zod.number(), zod.boolean()])),
						zod.null()
					]),
					state_id: zod.number(),
					num_solutions: zod.number()
				})
				.describe(
					'A model that functions as a reference to solutions existing in the database.\n\nReferenced solutions are not necessarily solutions that the user has saved explicitly. For\nreferencing those, see `SavedSolutionReference`.'
				)
		),
		user_results: zod.array(
			zod
				.object({
					name: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe('Optional name to help identify the solution if, e.g., saved.'),
					solution_index: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe(
							'The index of the referenced solution, if multiple solutions exist in the reference state.'
						),
					state: zod
						.object({
							id: zod.union([zod.number(), zod.null()]).optional(),
							problem_id: zod.union([zod.number(), zod.null()]).optional(),
							session_id: zod.union([zod.number(), zod.null()]).optional(),
							parent_id: zod.union([zod.number(), zod.null()]).optional(),
							state_id: zod.union([zod.number(), zod.null()]).optional()
						})
						.describe('State holder with a single relationship to the base State.'),
					objective_values_all: zod.array(zod.record(zod.string(), zod.number())),
					variable_values_all: zod.array(
						zod.record(
							zod.string(),
							zod.union([
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.union([
									zod.array(zod.any()),
									zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.literal('List'),
									zod.null()
								])
							])
						)
					),
					objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
					variable_values: zod.union([
						zod.record(zod.string(), zod.union([zod.number(), zod.number(), zod.boolean()])),
						zod.null()
					]),
					state_id: zod.number(),
					num_solutions: zod.number()
				})
				.describe(
					'A model that functions as a reference to solutions existing in the database.\n\nReferenced solutions are not necessarily solutions that the user has saved explicitly. For\nreferencing those, see `SavedSolutionReference`.'
				)
		),
		personal_result_index: zod.union([zod.number(), zod.null()])
	})
	.describe('The response for getting GNIMBUS results');

/**
 * Get all results from all iterations of the group.

Args:
    request (GroupInfoRequest): essentially just the ID of the group
    user (Annotated[User, Depends(get_current_user)]): current user
    session (Annotated[Session, Depends(get_session)])

Returns:
    GNIMBUSAllIterationsResponse: A GNIMBUSAllIterationsResponse response
    containing all the results of the iterations. If last iteration was optimization,
    the first iteration is incomplete (i.e. the voting preferences and voting results are missing)

Raises:
    HTTPException: Validation errors or no results or no states and such.
 * @summary Full Iteration
 */
export const fullIterationGnimbusAllIterationsPostBody = zod.object({
	group_id: zod.number()
});

export const fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemOptimizationPreferencesMethodDefault =
	'optimization';
export const fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemOptimizationPreferencesPhaseDefault =
	'learning';
export const fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemOptimizationPreferencesSetPreferencesPreferenceTypeDefault =
	'reference_point';
export const fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemVotingPreferencesMethodDefault =
	'voting';

export const fullIterationGnimbusAllIterationsPostResponse = zod
	.object({
		all_full_iterations: zod.array(
			zod.object({
				phase: zod.string(),
				optimization_preferences: zod.union([
					zod
						.object({
							method: zod
								.string()
								.default(
									fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemOptimizationPreferencesMethodDefault
								),
							phase: zod
								.string()
								.default(
									fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemOptimizationPreferencesPhaseDefault
								),
							set_preferences: zod.record(
								zod.string(),
								zod
									.object({
										preference_type: zod
											.literal('reference_point')
											.default(
												fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemOptimizationPreferencesSetPreferencesPreferenceTypeDefault
											),
										aspiration_levels: zod.record(zod.string(), zod.number())
									})
									.describe('Model for representing a reference point type of preference.')
							)
						})
						.describe(
							'An optimization preference class. As for the method and phase, see GNIMBUS for details.'
						),
					zod.null()
				]),
				voting_preferences: zod.union([
					zod
						.object({
							method: zod
								.string()
								.default(
									fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemVotingPreferencesMethodDefault
								),
							set_preferences: zod.record(zod.string(), zod.number())
						})
						.describe('Voting preferences'),
					zod.null()
				]),
				starting_result: zod.union([
					zod
						.object({
							name: zod
								.union([zod.string(), zod.null()])
								.optional()
								.describe('Optional name to help identify the solution if, e.g., saved.'),
							solution_index: zod
								.union([zod.number(), zod.null()])
								.optional()
								.describe(
									'The index of the referenced solution, if multiple solutions exist in the reference state.'
								),
							state: zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									problem_id: zod.union([zod.number(), zod.null()]).optional(),
									session_id: zod.union([zod.number(), zod.null()]).optional(),
									parent_id: zod.union([zod.number(), zod.null()]).optional(),
									state_id: zod.union([zod.number(), zod.null()]).optional()
								})
								.describe('State holder with a single relationship to the base State.'),
							objective_values_all: zod.array(zod.record(zod.string(), zod.number())),
							variable_values_all: zod.array(
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.any()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								)
							),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(zod.string(), zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.null()
							]),
							state_id: zod.number(),
							num_solutions: zod.number()
						})
						.describe(
							'A model that functions as a reference to solutions existing in the database.\n\nReferenced solutions are not necessarily solutions that the user has saved explicitly. For\nreferencing those, see `SavedSolutionReference`.'
						),
					zod.null()
				]),
				common_results: zod.array(
					zod
						.object({
							name: zod
								.union([zod.string(), zod.null()])
								.optional()
								.describe('Optional name to help identify the solution if, e.g., saved.'),
							solution_index: zod
								.union([zod.number(), zod.null()])
								.optional()
								.describe(
									'The index of the referenced solution, if multiple solutions exist in the reference state.'
								),
							state: zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									problem_id: zod.union([zod.number(), zod.null()]).optional(),
									session_id: zod.union([zod.number(), zod.null()]).optional(),
									parent_id: zod.union([zod.number(), zod.null()]).optional(),
									state_id: zod.union([zod.number(), zod.null()]).optional()
								})
								.describe('State holder with a single relationship to the base State.'),
							objective_values_all: zod.array(zod.record(zod.string(), zod.number())),
							variable_values_all: zod.array(
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.any()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								)
							),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(zod.string(), zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.null()
							]),
							state_id: zod.number(),
							num_solutions: zod.number()
						})
						.describe(
							'A model that functions as a reference to solutions existing in the database.\n\nReferenced solutions are not necessarily solutions that the user has saved explicitly. For\nreferencing those, see `SavedSolutionReference`.'
						)
				),
				user_results: zod.array(
					zod
						.object({
							name: zod
								.union([zod.string(), zod.null()])
								.optional()
								.describe('Optional name to help identify the solution if, e.g., saved.'),
							solution_index: zod
								.union([zod.number(), zod.null()])
								.optional()
								.describe(
									'The index of the referenced solution, if multiple solutions exist in the reference state.'
								),
							state: zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									problem_id: zod.union([zod.number(), zod.null()]).optional(),
									session_id: zod.union([zod.number(), zod.null()]).optional(),
									parent_id: zod.union([zod.number(), zod.null()]).optional(),
									state_id: zod.union([zod.number(), zod.null()]).optional()
								})
								.describe('State holder with a single relationship to the base State.'),
							objective_values_all: zod.array(zod.record(zod.string(), zod.number())),
							variable_values_all: zod.array(
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.any()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								)
							),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(zod.string(), zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.null()
							]),
							state_id: zod.number(),
							num_solutions: zod.number()
						})
						.describe(
							'A model that functions as a reference to solutions existing in the database.\n\nReferenced solutions are not necessarily solutions that the user has saved explicitly. For\nreferencing those, see `SavedSolutionReference`.'
						)
				),
				personal_result_index: zod.union([zod.number(), zod.null()]),
				final_result: zod.union([
					zod
						.object({
							name: zod
								.union([zod.string(), zod.null()])
								.optional()
								.describe('Optional name to help identify the solution if, e.g., saved.'),
							solution_index: zod
								.union([zod.number(), zod.null()])
								.optional()
								.describe(
									'The index of the referenced solution, if multiple solutions exist in the reference state.'
								),
							state: zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									problem_id: zod.union([zod.number(), zod.null()]).optional(),
									session_id: zod.union([zod.number(), zod.null()]).optional(),
									parent_id: zod.union([zod.number(), zod.null()]).optional(),
									state_id: zod.union([zod.number(), zod.null()]).optional()
								})
								.describe('State holder with a single relationship to the base State.'),
							objective_values_all: zod.array(zod.record(zod.string(), zod.number())),
							variable_values_all: zod.array(
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.any()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								)
							),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(zod.string(), zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.null()
							]),
							state_id: zod.number(),
							num_solutions: zod.number()
						})
						.describe(
							'A model that functions as a reference to solutions existing in the database.\n\nReferenced solutions are not necessarily solutions that the user has saved explicitly. For\nreferencing those, see `SavedSolutionReference`.'
						),
					zod.null()
				])
			})
		)
	})
	.describe('The response model for getting all found solutions among others');

/**
 * Toggle the phase from learning to decision and vice versa
 * @summary Toggle Phase
 */
export const togglePhaseGnimbusTogglePhasePostBody = zod
	.object({
		group_id: zod.number(),
		new_phase: zod.string()
	})
	.describe('A request for a certain phase. Comes from the group owner/analyst');

export const togglePhaseGnimbusTogglePhasePostResponse = zod
	.object({
		old_phase: zod.string(),
		new_phase: zod.string()
	})
	.describe('A response for the above request.');

/**
 * Create group.

Args:
    request (GroupCreateRequest): a request that holds information to be used in creation of the group.
    user (Annotated[User, Depends(get_current_user)]): the current user.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: Aknowledgement that the gourp was created

Raises:
    HTTPException
 * @summary Create Group
 */
export const createGroupGdmCreateGroupPostBody = zod
	.object({
		group_name: zod.string(),
		problem_id: zod.number()
	})
	.describe('Used for requesting a group to be created');

export const createGroupGdmCreateGroupPostResponse = zod.any();

/**
 * Delete the group with given ID

Args:
    request (GroupInfoRequest): Contains the ID of the group to be deleted
    user (Annotated[User, Depends(get_current_user)]): The user (in this case must be owner for anything to happen)
    session (Annotated[Session, Depends(get_session)]): The database session

Returns:
    JSONResponse: Aknowledgement of the deletion

Raises:
    HTTPException: Insufficient authorization etc.
 * @summary Delete Group
 */
export const deleteGroupGdmDeleteGroupPostBody = zod.object({
	group_id: zod.number()
});

export const deleteGroupGdmDeleteGroupPostResponse = zod.any();

/**
 * Add a user to a group.

Args:
    request (GroupModifyRequest): Request object that has group and user IDs.
    user (Annotated[User, Depends(get_current_user)]): the current user.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: Aknowledge that user has been added to the group

Raises:
    HTTPException: Authorization issues, group or user not found.
 * @summary Add To Group
 */
export const addToGroupGdmAddToGroupPostBody = zod
	.object({
		group_id: zod.number(),
		user_id: zod.number()
	})
	.describe('Used for adding a user into group and removing a user from group');

export const addToGroupGdmAddToGroupPostResponse = zod.any();

/**
 * Remove user from group.

Args:
    request (GroupModifyRequest): Request object that has group and user IDs.
    user (Annotated[User, Depends(get_current_user)]): the current user.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: Aknowledge that user has been removed from the group.

Raises:
    HTTPException: Authorization issues, group or user not found.
 * @summary Remove From Group
 */
export const removeFromGroupGdmRemoveFromGroupPostBody = zod
	.object({
		group_id: zod.number(),
		user_id: zod.number()
	})
	.describe('Used for adding a user into group and removing a user from group');

export const removeFromGroupGdmRemoveFromGroupPostResponse = zod.any();

/**
 * Get information about the group

Args:
    request (GroupInfoRequest): the id of the group for which we desire info on
    session (Annotated[Session, Depends(get_session)]): the database session

Returns:
    GroupPublic: public info of the group

Raises:
    HTTPException: If there's no group with the requests group id
 * @summary Get Group Info
 */
export const getGroupInfoGdmGetGroupInfoPostBody = zod.object({
	group_id: zod.number()
});

export const getGroupInfoGdmGetGroupInfoPostResponse = zod
	.object({
		id: zod.number(),
		name: zod.string(),
		owner_id: zod.number(),
		user_ids: zod.array(zod.number()),
		problem_id: zod.number()
	})
	.describe('Response model for Group');

/**
 * .
 * @summary Step
 */
export const stepMethodEnautilusStepPostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		representative_solutions_id: zod.union([zod.number(), zod.null()]).optional(),
		current_iteration: zod.number().describe('The number of the current iteration.'),
		iterations_left: zod.number().describe('The number of iterations left.'),
		selected_point: zod
			.record(zod.string(), zod.number())
			.describe(
				'The selected intermediate point. If first iteration, set this to be the (approximated) nadir point.'
			),
		reachable_point_indices: zod
			.array(zod.number())
			.describe(
				'The indices indicating the point on the non-dominated set that are reachable from the currently selected point.'
			),
		number_of_intermediate_points: zod
			.number()
			.describe('The number of intermediate points to be generated.')
	})
	.describe('Model of the request to the E-NAUTILUS method.');

export const stepMethodEnautilusStepPostResponse = zod
	.object({
		id: zod.union([zod.number(), zod.null()]).optional(),
		non_dominated_solutions_id: zod.union([zod.number(), zod.null()]).optional(),
		current_iteration: zod.number(),
		iterations_left: zod.number(),
		selected_point: zod.union([zod.record(zod.string(), zod.number()), zod.null()]).optional(),
		reachable_point_indices: zod.array(zod.number()).optional(),
		number_of_intermediate_points: zod.number(),
		enautilus_results: zod
			.object({
				current_iteration: zod.number().describe('Number of the current iteration.'),
				iterations_left: zod.number().describe('Number of iterations left.'),
				intermediate_points: zod
					.array(zod.record(zod.string(), zod.number()))
					.describe('New intermediate points'),
				reachable_best_bounds: zod
					.array(zod.record(zod.string(), zod.number()))
					.describe(
						'Best bounds of the objective function values reachable from each intermediate point.'
					),
				reachable_worst_bounds: zod
					.array(zod.record(zod.string(), zod.number()))
					.describe(
						'Worst bounds of the objective function values reachable from each intermediate point.'
					),
				closeness_measures: zod
					.array(zod.number())
					.describe('Closeness measures of each intermediate point.'),
				reachable_point_indices: zod
					.array(zod.array(zod.number()))
					.describe('Indices of the reachable points from each intermediate point.')
			})
			.describe('The result of an iteration of the E-NAUTILUS method.')
	})
	.describe('E-NAUTILUS: one stepping iteration.');
